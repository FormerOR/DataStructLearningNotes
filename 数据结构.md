---
typora-root-url: 图片
---

# 数据结构自学笔记

## 第一章 绪论

### 1.1 基本概念中及逻辑结构

![image-20230713140022680](C:\Users\linxuefeng\AppData\Roaming\Typora\typora-user-images\image-20230713140022680.png)

![image-20230713140047317](C:\Users\linxuefeng\AppData\Roaming\Typora\typora-user-images\image-20230713140047317.png)

![image-20230713142613721](C:\Users\linxuefeng\AppData\Roaming\Typora\typora-user-images\image-20230713142613721.png)

### 1.2 存储结构和数据的运算

存储结构包括：

* 顺序存储结构
* 链式存储结构
* 索引存储结构
* 散列存储结构

![image-20230713140138963](C:\Users\linxuefeng\AppData\Roaming\Typora\typora-user-images\image-20230713140138963.png)

![image-20230713140343741](C:\Users\linxuefeng\AppData\Roaming\Typora\typora-user-images\image-20230713140343741.png)

![image-20230713140451105](C:\Users\linxuefeng\AppData\Roaming\Typora\typora-user-images\image-20230713140451105.png)

---



![image-20230713140525329](C:\Users\linxuefeng\AppData\Roaming\Typora\typora-user-images\image-20230713140525329.png)

数据的运算包含：

* 搜索运算
* 插入运算
* 删除运算
* 更新运算

### 1.3 算法和算法分析

![image-20230713141235345](C:\Users\linxuefeng\AppData\Roaming\Typora\typora-user-images\image-20230713141235345.png)

![image-20230713141310252](C:\Users\linxuefeng\AppData\Roaming\Typora\typora-user-images\image-20230713141310252.png)

* 输入
* 输出
* 可行性
* 确定性
* 有穷性

![image-20230713141456484](C:\Users\linxuefeng\AppData\Roaming\Typora\typora-user-images\image-20230713141456484.png)

![image-20230713141510025](C:\Users\linxuefeng\AppData\Roaming\Typora\typora-user-images\image-20230713141510025.png)

![image-20230713141519364](C:\Users\linxuefeng\AppData\Roaming\Typora\typora-user-images\image-20230713141519364.png)

---

![image-20230713141602201](C:\Users\linxuefeng\AppData\Roaming\Typora\typora-user-images\image-20230713141602201.png)



![image-20230713141727659](C:\Users\linxuefeng\AppData\Roaming\Typora\typora-user-images\image-20230713141727659.png)

#### **渐进时间复杂度**![image-20230713141734510](C:\Users\linxuefeng\AppData\Roaming\Typora\typora-user-images\image-20230713141734510.png)

![image-20230713141805804](C:\Users\linxuefeng\AppData\Roaming\Typora\typora-user-images\image-20230713141805804.png)

![image-20230713141946526](C:\Users\linxuefeng\AppData\Roaming\Typora\typora-user-images\image-20230713141946526.png)

![image-20230713142006513](C:\Users\linxuefeng\AppData\Roaming\Typora\typora-user-images\image-20230713142006513.png)

![image-20230713142135163](C:\Users\linxuefeng\AppData\Roaming\Typora\typora-user-images\image-20230713142135163.png)

![image-20230713142141641](C:\Users\linxuefeng\AppData\Roaming\Typora\typora-user-images\image-20230713142141641.png)

#### 最好最坏和平均时间复杂度

![image-20230713142232089](C:\Users\linxuefeng\AppData\Roaming\Typora\typora-user-images\image-20230713142232089.png)

![image-20230713142240049](C:\Users\linxuefeng\AppData\Roaming\Typora\typora-user-images\image-20230713142240049.png)

#### 空间复杂度

![image-20230713142333602](C:\Users\linxuefeng\AppData\Roaming\Typora\typora-user-images\image-20230713142333602.png)

![image-20230713142345310](C:\Users\linxuefeng\AppData\Roaming\Typora\typora-user-images\image-20230713142345310.png)



## 第二章 线性表

![image-20230713142545809](C:\Users\linxuefeng\AppData\Roaming\Typora\typora-user-images\image-20230713142545809.png)

### 2.1 线性表的定义

![image-20230713142656253](C:\Users\linxuefeng\AppData\Roaming\Typora\typora-user-images\image-20230713142656253.png)

![image-20230713142707516](C:\Users\linxuefeng\AppData\Roaming\Typora\typora-user-images\image-20230713142707516.png)

#### 直接前驱、直接后驱的概念

![image-20230713142732068](C:\Users\linxuefeng\AppData\Roaming\Typora\typora-user-images\image-20230713142732068.png)

#### 线性表的描述规范

![image-20230713143027008](C:\Users\linxuefeng\AppData\Roaming\Typora\typora-user-images\image-20230713143027008.png)

![image-20230713143035450](C:\Users\linxuefeng\AppData\Roaming\Typora\typora-user-images\image-20230713143035450.png)

### ![image-20230713143922682](C:\Users\linxuefeng\AppData\Roaming\Typora\typora-user-images\image-20230713143922682.png)

### 2.2 线性表的顺序存储

#### 2.2.1顺序表的定义

![image-20230713144015090](C:\Users\linxuefeng\AppData\Roaming\Typora\typora-user-images\image-20230713144015090.png)

![image-20230713144030387](C:\Users\linxuefeng\AppData\Roaming\Typora\typora-user-images\image-20230713144030387.png)

![image-20230713144040053](C:\Users\linxuefeng\AppData\Roaming\Typora\typora-user-images\image-20230713144040053.png)

![image-20230713144105741](C:\Users\linxuefeng\AppData\Roaming\Typora\typora-user-images\image-20230713144105741.png)

#### 2.2.2 顺序表的基本运算

##### 插入运算

![image-20230713144506433](C:\Users\linxuefeng\AppData\Roaming\Typora\typora-user-images\image-20230713144506433.png)

![image-20230713144513164](C:\Users\linxuefeng\AppData\Roaming\Typora\typora-user-images\image-20230713144513164.png)

##### 删除运算

![image-20230713144550778](C:\Users\linxuefeng\AppData\Roaming\Typora\typora-user-images\image-20230713144550778.png)

![image-20230713144557434](C:\Users\linxuefeng\AppData\Roaming\Typora\typora-user-images\image-20230713144557434.png)

![image-20230713145759748](C:\Users\linxuefeng\AppData\Roaming\Typora\typora-user-images\image-20230713145759748.png)

### 2.3 线性表的链接存储

![image-20230713145833216](C:\Users\linxuefeng\AppData\Roaming\Typora\typora-user-images\image-20230713145833216.png)

#### 2.3.1 单链表的定义

![image-20230713145946016](C:\Users\linxuefeng\AppData\Roaming\Typora\typora-user-images\image-20230713145946016.png)

每个结点只包含一个指针域的链表，称作单链表

![image-20230713151312139](C:\Users\linxuefeng\AppData\Roaming\Typora\typora-user-images\image-20230713151312139.png)

![image-20230713152527184](C:\Users\linxuefeng\AppData\Roaming\Typora\typora-user-images\image-20230713152527184.png)

![image-20230713152539516](C:\Users\linxuefeng\AppData\Roaming\Typora\typora-user-images\image-20230713152539516.png)

![image-20230713152609560](C:\Users\linxuefeng\AppData\Roaming\Typora\typora-user-images\image-20230713152609560.png)

#### 2.3.2 单链表的插入操作

![image-20230713153513292](C:\Users\linxuefeng\AppData\Roaming\Typora\typora-user-images\image-20230713153513292.png)

![image-20230713153541728](C:\Users\linxuefeng\AppData\Roaming\Typora\typora-user-images\image-20230713153541728.png)

![image-20230713153654212](C:\Users\linxuefeng\AppData\Roaming\Typora\typora-user-images\image-20230713153654212.png)

![image-20230713153755026](C:\Users\linxuefeng\AppData\Roaming\Typora\typora-user-images\image-20230713153755026.png)

![image-20230713154645736](C:\Users\linxuefeng\AppData\Roaming\Typora\typora-user-images\image-20230713154645736.png)

![image-20230713154801190](C:\Users\linxuefeng\AppData\Roaming\Typora\typora-user-images\image-20230713154801190.png)

#### 2.3.3 单链表的删除操作

![image-20230713155355106](C:\Users\linxuefeng\AppData\Roaming\Typora\typora-user-images\image-20230713155355106.png)

![image-20230713155437084](C:\Users\linxuefeng\AppData\Roaming\Typora\typora-user-images\image-20230713155437084.png)

![image-20230713155545897](C:\Users\linxuefeng\AppData\Roaming\Typora\typora-user-images\image-20230713155545897.png)

![image-20230713155616766](C:\Users\linxuefeng\AppData\Roaming\Typora\typora-user-images\image-20230713155616766.png)

![image-20230713155637519](C:\Users\linxuefeng\AppData\Roaming\Typora\typora-user-images\image-20230713155637519.png)

![image-20230713155903627](C:\Users\linxuefeng\AppData\Roaming\Typora\typora-user-images\image-20230713155903627.png)

#### 2.3.4 带表头结点的单链表

**回顾**

![image-20230713160600329](C:\Users\linxuefeng\AppData\Roaming\Typora\typora-user-images\image-20230713160600329.png)

![image-20230713160645996](C:\Users\linxuefeng\AppData\Roaming\Typora\typora-user-images\image-20230713160645996.png)

![image-20230713160704621](C:\Users\linxuefeng\AppData\Roaming\Typora\typora-user-images\image-20230713160704621.png)

![image-20230713160717227](C:\Users\linxuefeng\AppData\Roaming\Typora\typora-user-images\image-20230713160717227.png)

![image-20230713160904120](C:\Users\linxuefeng\AppData\Roaming\Typora\typora-user-images\image-20230713160904120.png)

![image-20230713160915958](C:\Users\linxuefeng\AppData\Roaming\Typora\typora-user-images\image-20230713160915958.png)

![image-20230713161545270](C:\Users\linxuefeng\AppData\Roaming\Typora\typora-user-images\image-20230713161545270.png)

**总结：不用分类讨论是否插入或者删除的结点是表头的情况**

#### 2.3.5 循环链表及双向链表

##### **单循环链表**

![image-20230713162147951](C:\Users\linxuefeng\AppData\Roaming\Typora\typora-user-images\image-20230713162147951.png)

首尾相连形成一个环

为单循环链表添加表头结点后

![image-20230713162425729](C:\Users\linxuefeng\AppData\Roaming\Typora\typora-user-images\image-20230713162425729.png)

##### 双向链表

![image-20230713162527859](C:\Users\linxuefeng\AppData\Roaming\Typora\typora-user-images\image-20230713162527859.png)

![image-20230713162645730](C:\Users\linxuefeng\AppData\Roaming\Typora\typora-user-images\image-20230713162645730.png)

![image-20230713162834009](C:\Users\linxuefeng\AppData\Roaming\Typora\typora-user-images\image-20230713162834009.png)

先把新结点与两头接进去，再连接左右节点向新节点

### 2.3 线性表的应用

#### 一元整系数多项式

![image-20230713164433166](C:\Users\linxuefeng\AppData\Roaming\Typora\typora-user-images\image-20230713164433166.png)

![image-20230713164508821](C:\Users\linxuefeng\AppData\Roaming\Typora\typora-user-images\image-20230713164508821.png)

![image-20230713164644097](C:\Users\linxuefeng\AppData\Roaming\Typora\typora-user-images\image-20230713164644097.png)

![image-20230713164733985](C:\Users\linxuefeng\AppData\Roaming\Typora\typora-user-images\image-20230713164733985.png)

![image-20230713164822226](C:\Users\linxuefeng\AppData\Roaming\Typora\typora-user-images\image-20230713164822226.png)

## 第三章 堆栈和队列

### 3.1 堆栈

#### 3.1.1 堆栈的基本概念与ADT

![image-20230714205823970](C:\Users\linxuefeng\AppData\Roaming\Typora\typora-user-images\image-20230714205823970.png)

![image-20230714205833063](C:\Users\linxuefeng\AppData\Roaming\Typora\typora-user-images\image-20230714205833063.png)

![image-20230714205940228](C:\Users\linxuefeng\AppData\Roaming\Typora\typora-user-images\image-20230714205940228.png)

![image-20230714210001850](C:\Users\linxuefeng\AppData\Roaming\Typora\typora-user-images\image-20230714210001850.png)

#### 3.1.2 堆栈的顺序表示

![image-20230714210331536](C:\Users\linxuefeng\AppData\Roaming\Typora\typora-user-images\image-20230714210331536.png)

![image-20230714210428147](C:\Users\linxuefeng\AppData\Roaming\Typora\typora-user-images\image-20230714210428147.png)

![image-20230714210528878](C:\Users\linxuefeng\AppData\Roaming\Typora\typora-user-images\image-20230714210528878.png)

![image-20230714210618704](C:\Users\linxuefeng\AppData\Roaming\Typora\typora-user-images\image-20230714210618704.png)

![image-20230714210708539](C:\Users\linxuefeng\AppData\Roaming\Typora\typora-user-images\image-20230714210708539.png)

![image-20230714210803219](C:\Users\linxuefeng\AppData\Roaming\Typora\typora-user-images\image-20230714210803219.png)

插入前下标一直指在栈顶的元素上，而不会悬空，是先移动下标再赋值。

![image-20230714210913475](C:\Users\linxuefeng\AppData\Roaming\Typora\typora-user-images\image-20230714210913475.png)

出栈直接将下标减一，这样下次入栈时直接覆盖原来没有删除的数据

疑惑：那这样是不是如果我错误的出栈了一个元素，只需要将栈的top值+1就可以找回原来的元素？

我觉得，这种出栈机制在某些场景可能会出现安全问题，比如如果有人可以访问你的数组或栈的内存空间，他们可能会读取或修改你已经出栈的元素，从而导致数据泄露或破坏

![image-20230714211852416](C:\Users\linxuefeng\AppData\Roaming\Typora\typora-user-images\image-20230714211852416.png)

![image-20230714212057332](C:\Users\linxuefeng\AppData\Roaming\Typora\typora-user-images\image-20230714212057332.png)

### 3.2 队列

#### 3.2.1 队列的基本概念和ADT

![image-20230714212409907](C:\Users\linxuefeng\AppData\Roaming\Typora\typora-user-images\image-20230714212409907.png)

![image-20230714212451730](C:\Users\linxuefeng\AppData\Roaming\Typora\typora-user-images\image-20230714212451730.png)

![image-20230714212526750](C:\Users\linxuefeng\AppData\Roaming\Typora\typora-user-images\image-20230714212526750.png)

![image-20230714213501829](C:\Users\linxuefeng\AppData\Roaming\Typora\typora-user-images\image-20230714213501829.png)

![image-20230714213531817](C:\Users\linxuefeng\AppData\Roaming\Typora\typora-user-images\image-20230714213531817.png)

#### 3.2.2 队列的顺序表示和循环队列

![image-20230714213722692](C:\Users\linxuefeng\AppData\Roaming\Typora\typora-user-images\image-20230714213722692.png)

队的对头居然不是第一个元素而是第一个元素前的单元下标，同时maxSize的范围也是从front开始算而不是a0

![image-20230714214003550](C:\Users\linxuefeng\AppData\Roaming\Typora\typora-user-images\image-20230714214003550.png)

![image-20230714214140252](C:\Users\linxuefeng\AppData\Roaming\Typora\typora-user-images\image-20230714214140252.png)

![image-20230714214208777](C:\Users\linxuefeng\AppData\Roaming\Typora\typora-user-images\image-20230714214208777.png)

#### 3.2.3 队列的实现

![image-20230714214534680](C:\Users\linxuefeng\AppData\Roaming\Typora\typora-user-images\image-20230714214534680.png)

![image-20230714214630925](C:\Users\linxuefeng\AppData\Roaming\Typora\typora-user-images\image-20230714214630925.png)

![image-20230714214832549](C:\Users\linxuefeng\AppData\Roaming\Typora\typora-user-images\image-20230714214832549.png)

![image-20230714215033930](C:\Users\linxuefeng\AppData\Roaming\Typora\typora-user-images\image-20230714215033930.png)

循环队列都是获取相对下标而不是绝对下标，因为在实际中front值会一直移动改变而不是在element的第二位

![image-20230714215211151](C:\Users\linxuefeng\AppData\Roaming\Typora\typora-user-images\image-20230714215211151.png)

没满的话就先向前移动下标并赋值

![image-20230714215333077](C:\Users\linxuefeng\AppData\Roaming\Typora\typora-user-images\image-20230714215333077.png)

出队操作依然是只向前移动下标而不是删除后在前移下标

![image-20230714215554266](C:\Users\linxuefeng\AppData\Roaming\Typora\typora-user-images\image-20230714215554266.png)

![image-20230714215816558](C:\Users\linxuefeng\AppData\Roaming\Typora\typora-user-images\image-20230714215816558.png)

### 3.总结

* 对于堆栈和队列而言，用顺序表实现和用链接表实现，哪种方法更好，为什么？
  * 对于堆栈来说只需要在一段进行删除和插入操作，所以用顺序表实现效率较高，只需要一个数组以及栈顶指针。当然，也可以用链接表实现，但是需要额外的空间存储指针，并且不能随机访问栈中的元素。
  * 对于队列来说，它在两端进行插入和删除操作，所以用链接表实现比较方便灵活，只需要一个头节点和一个尾节点即可。如果用顺序表实现，就需要一个环形数组和两个指针来标识队头和队尾，并且要考虑队列满和队列空的情况。

[在基于顺序表实现的循环队列中，预留一个不可用的单元空间是为了区分队列空和队列满的情况，因为如果不预留空间，当队列空和队列满时，都会出现front=rear的情况，无法判断](https://zhuanlan.zhihu.com/p/457276381)[1](https://zhuanlan.zhihu.com/p/457276381)。所以，预留一个空间是一种简单有效的方法，但不是必须的。

如果不预留空间，也有其他的方法来判断队列空和队列满，例如：

- [增加一个标志位flag，当front=rear时，如果flag=0，表示队列空；如果flag=1，表示队列满。入队时将flag置为1，出队时将flag置为0](https://zhuanlan.zhihu.com/p/356925748)[2](https://zhuanlan.zhihu.com/p/356925748)。
- [增加一个计数器count，记录队列中元素的个数。当count=0时，表示队列空；当count=maxSize时，表示队列满。入队时将count加1，出队时将count减1](https://zhuanlan.zhihu.com/p/266012147)[3](https://zhuanlan.zhihu.com/p/266012147)。
- 用链表来实现循环队列，这样就不需要预留空间，也不需要判断队列满的情况。

有两种链表，只需要一个指针就可以很方便的实现队列，它们分别是：

- 单向循环链表，这种链表的特点是最后一个节点的next指针指向第一个节点，形成一个环。只需要一个指针rear，指向队尾节点，就可以实现队列的插入和删除操作。具体如下：
  - 入队时，先创建一个新节点，将其数据域赋值为待插入的元素，然后将其next指针指向rear的next（也就是队头节点），再将rear的next指针指向新节点，最后将rear更新为新节点。
  - 出队时，先判断队列是否为空，如果为空则返回空值或抛出异常。如果不为空，则先将rear的next（也就是队头节点）保存为临时变量temp，然后将rear的next指针更新为temp的next（也就是新的队头节点），再将temp的next指针置空，最后返回temp的数据域。
- 双向链表，这种链表的特点是每个节点有两个指针，分别指向前驱节点和后继节点。只需要一个指针head，指向队头节点，就可以实现队列的插入和删除操作。具体如下：
  - 入队时，先创建一个新节点，将其数据域赋值为待插入的元素，然后判断队列是否为空。如果为空，则将head更新为新节点。如果不为空，则先将新节点的prev指针指向head的prev（也就是队尾节点），再将head的prev的next指针指向新节点，最后将head的prev更新为新节点。
  - 出队时，先判断队列是否为空，如果为空则返回空值或抛出异常。如果不为空，则先将head保存为临时变量temp，然后判断head是否是唯一的节点（即head的prev和next都是空）。如果是，则将head置空。如果不是，则先将head的next的prev指针置空，再将head更新为head的next。最后返回temp的数据域。

### 3.3 表达式

#### 3.3.1 表达式与后缀表达式求值

![image-20230715141038216](/image-20230715141038216.png)

![image-20230715141145938](/image-20230715141145938.png)

利用堆栈 来计算后缀表达式![image-20230715141228725](/image-20230715141228725.png)

![image-20230715141438189](/image-20230715141438189.png)

![image-20230715141547348](/image-20230715141547348.png)

#### 3.3.2 中缀表达式到后缀表达式的转换

![image-20230715141655325](/image-20230715141655325.png)

![image-20230715141914732](/image-20230715141914732.png)

![image-20230715142127543](/image-20230715142127543.png)

![image-20230715142146564](/image-20230715142146564.png)

![image-20230715142150892](/image-20230715142150892.png)

![image-20230715142157403](/image-20230715142157403.png)

这也太复杂了，特别是这个栈内栈外优先级，是人想出来的东西吗:facepunch:

#### 总结一下：:notebook:

* 不论栈内栈外，**乘除**的优先级**永远大于**加减

* 栈内的操作符从底部到顶部遵循**从小到大**的规则，所以当一个小的操作符要入栈时，必须先将大于他的操作符出栈
* **左括号外面大里面小**，因为在外面总是先于右括号被扫描到，在右括号被扫描到的时候就说明要其上的元素全部出栈输出了
* **右括号优先级与左括号相反**

### 3.4 递归

![image-20230715151635683](/image-20230715151635683.png)

#### 3.4.1 递归1

![image-20230715151703106](/image-20230715151703106.png)

![image-20230715151814686](/image-20230715151814686.png)

![image-20230715151832160](/image-20230715151832160.png)

![image-20230715151910207](/image-20230715151910207.png)

#### 3.4.2 递归2

![image-20230715152034500](/image-20230715152034500.png)

![image-20230715152153384](/image-20230715152153384.png)

![image-20230715152206341](/image-20230715152206341.png)

![image-20230715152342147](/image-20230715152342147.png)

## 第四章 数组

### 4.1 数组的基本概念

![image-20230715160710753](/image-20230715160710753.png)

#### 4.1.1 C语言中的数组

![image-20230715160738057](/image-20230715160738057.png)

![image-20230715160807277](/image-20230715160807277.png)

![image-20230715160838369](/image-20230715160838369.png)

#### 4.1.2 数组的顺序存储

![image-20230715160940113](/image-20230715160940113.png)

![image-20230715160955930](/image-20230715160955930.png)

![image-20230715161010141](/image-20230715161010141.png)

![image-20230715161049845](/image-20230715161049845.png)

![image-20230715161128704](/image-20230715161128704.png)

![image-20230715161226176](/image-20230715161226176.png)

![image-20230715161319085](/image-20230715161319085.png)

![image-20230715161340314](/image-20230715161340314.png)

4.1.3 数组的抽象数据类型

![image-20230715161636183](/image-20230715161636183.png)

![image-20230715161703982](/image-20230715161703982.png)

![image-20230715161732203](/image-20230715161732203.png)

![image-20230715161808944](/image-20230715161808944.png)

![image-20230715161835560](/image-20230715161835560.png)

![image-20230715161903211](/image-20230715161903211.png)

![image-20230715162018954](/image-20230715162018954.png)

![image-20230715162036490](/image-20230715162036490.png)

![image-20230715162115466](/image-20230715162115466.png)

### 4.2 特殊矩阵

![image-20230715162357016](/image-20230715162357016.png)

![image-20230715162504467](/image-20230715162504467.png)

![image-20230715162526143](/image-20230715162526143.png)

![image-20230715162611634](/image-20230715162611634.png)

![image-20230715162702205](/image-20230715162702205.png)

![image-20230715162728309](/image-20230715162728309.png)

![image-20230715162736420](/image-20230715162736420.png)

![image-20230715162744671](/image-20230715162744671.png)

#### 4.3.1 稀疏矩阵的抽象数据类型

![image-20230715163754383](/image-20230715163754383.png)

![image-20230715164016158](/image-20230715164016158.png)

![image-20230715164114384](/image-20230715164114384.png)

![image-20230715164210620](/image-20230715164210620.png)

![image-20230715164423444](/image-20230715164423444.png)

#### 4.3.2 系数矩阵的两个转置算法

![image-20230715165051622](/image-20230715165051622.png)

![image-20230715165203807](/image-20230715165203807.png)

![image-20230715165252389](/image-20230715165252389.png)



![image-20230715165322375](/image-20230715165322375.png)

只有稳定的排序算法才可以（即不改变相对位置的排序算法，同一数值下的两个元素在排序后保持原有的顺序）

![image-20230715165418854](/image-20230715165418854.png)

![image-20230715165507210](/image-20230715165507210.png)

#### 4.3.3 稀疏矩阵的快速转置算法

![image-20230715170525902](/image-20230715170525902.png)

![image-20230715172338763](/image-20230715172338763.png)

num数组记录A每一列的非零元个数

![image-20230715172452342](/image-20230715172452342.png)

K数组记录第j列第一个非零元在B中的下标

`k[0]=0,k[j] = k[j-1] + num[k-1]`

![image-20230715172543358](/image-20230715172543358.png)

1. 扫描A的第一个非零元组，利用其列号在k数组中查找这个非零元组在B中的存储下标，同时k数组对应列号的值加一，这样下次遇到同一列号的非零元组时能够存放在上一个的下一个位置。
2. 交换行列号并且存放非零元的值

#### 4.3.4 快速转置算法实例演示

1. 算num数组

![image-20230715173106387](/image-20230715173106387.png)

2. 算k数组

![image-20230715173229935](/image-20230715173229935.png)



开始扫描：

![image-20230715173315566](/image-20230715173315566.png)

交换赋值后对应k加一

....

![image-20230715173453160](/image-20230715173453160.png)

#### 总结：

* 利用观察统计规律

* 以空间换时间的一种算法

## 第五章 树和二叉树

![image-20230718092757101](/image-20230718092757101.png)

### 5.1 树:christmas_tree:

![image-20230718092924839](/image-20230718092924839.png)

#### 5.1.1 树的定义

![image-20230718093034499](/image-20230718093034499.png)

![image-20230718093106550](/image-20230718093106550.png)

![image-20230718093223823](/image-20230718093223823.png)

![image-20230718093308747](/image-20230718093308747.png)

![image-20230718093355460](/image-20230718093355460.png)

![image-20230718093459772](/image-20230718093459772.png)

![image-20230718093515817](/image-20230718093515817.png)

#### 5.1.2 树的基本术语

![image-20230718093721023](/image-20230718093721023.png)

![image-20230718093836188](/image-20230718093836188.png)

![image-20230718093921758](/image-20230718093921758.png)

![image-20230718094117858](/image-20230718094117858.png)

![image-20230718094206737](/image-20230718094206737.png)

![image-20230718094230659](/image-20230718094230659.png)

![image-20230718094311240](/image-20230718094311240.png)

![image-20230718094331108](/image-20230718094331108.png)

* 总结术语
  * 结点
  * 路径
  * 双亲
  * 孩子
  * 兄弟
  * 后裔
  * 祖新
  * 结点的度
  * 叶子
  * 分支节点
  * 树的度
  * 结点的层次
  * 书的高度
  * 无序树
  * 有序树
  * 森林

### 5.2 二叉树

![image-20230718095750829](/image-20230718095750829.png)

#### 5.2.1 二叉树的定义及性质

![image-20230718095850089](/image-20230718095850089.png)

![image-20230718100017250](/image-20230718100017250.png)

![image-20230718100050625](/image-20230718100050625.png)

![image-20230718100131438](/image-20230718100131438.png)

![image-20230718100156638](/image-20230718100156638.png)

![image-20230718100234452](/image-20230718100234452.png)

![image-20230718100301840](/image-20230718100301840.png)

![image-20230718100318692](/image-20230718100318692.png)

![image-20230718100413990](/image-20230718100413990.png)

![image-20230718100549083](/image-20230718100549083.png)

#### 5.2.2 特殊二叉树

![image-20230718100921937](/image-20230718100921937.png)

![image-20230718101119869](/image-20230718101119869.png)

![image-20230718101217587](/image-20230718101217587.png)

![image-20230718101230960](/image-20230718101230960.png)

![image-20230718101324453](/image-20230718101324453.png)

![image-20230718101556401](/image-20230718101556401.png)

总结：

* 完全二叉树>扩充二叉树>满二叉树

* 扩充二叉树与完全二叉树的区别是，完全可以有度为1的结点，而扩充需要全部为0或者为2的结点

#### 5.2.3 二叉树ADT及存储表示

![image-20230718103015196](/image-20230718103015196.png)

![image-20230718103102636](/image-20230718103102636.png)

![image-20230718103114692](/image-20230718103114692.png)

![image-20230718103122551](/image-20230718103122551.png)

![image-20230718103149094](/image-20230718103149094.png)

![image-20230718103201823](/image-20230718103201823.png)

![image-20230718103217446](/image-20230718103217446.png)

![image-20230718103227098](/image-20230718103227098.png)

#### 5.2.4 二叉树的基本运算

![image-20230718103829713](/image-20230718103829713.png)

![image-20230718104117310](/image-20230718104117310.png)

![image-20230718104140234](/image-20230718104140234.png)

* 注：此时在根据左右两个树创建一个新树的时候，创建完成后旧树会被置零

![image-20230718104306655](/image-20230718104306655.png)

![image-20230718104400714](/image-20230718104400714.png)

![image-20230718104454038](/image-20230718104454038.png)

### 5.3 二叉树的遍历

![image-20230718184214916](/image-20230718184214916.png)

#### 5.3.1 二叉树遍历的基本概念和先序遍历

![image-20230718184303942](/image-20230718184303942.png)

![image-20230718184432421](/image-20230718184432421.png)

![image-20230718184509228](/image-20230718184509228.png)

![image-20230718184649077](/image-20230718184649077.png)

![image-20230718184903361](/image-20230718184903361.png)

#### 5.3.2 二叉树的中序和后序遍历

![image-20230718185514943](/image-20230718185514943.png)

![image-20230718185616951](/image-20230718185616951.png)

* 经验：可以把树补全以后再遍历，这样子出错的概率会小一点

![image-20230718185752244](/image-20230718185752244.png)

![image-20230718185815225](/image-20230718185815225.png)

![image-20230718185847451](/image-20230718185847451.png)

![image-20230718185907492](/image-20230718185907492.png)

* 相当于函数中的打印根节点的数据的语句分别在前中后的位置上

#### 5.3.3 二叉树的层次遍历

![image-20230718190435600](/image-20230718190435600.png)

![image-20230718190528719](/image-20230718190528719.png)

![image-20230718190631805](/image-20230718190631805.png)

![image-20230718190646411](/image-20230718190646411.png)

![image-20230718190727636](/image-20230718190727636.png)

![image-20230718190755324](/image-20230718190755324.png)

![image-20230718190814693](/image-20230718190814693.png)

![image-20230718191032840](/image-20230718191032840.png)

* 第一步是把根节点先加入队列
* 第二步是一个循环，如果队列有元素则将不断运行，直到队列为空则结束

#### 5.3.4 二叉树遍历的相关性质

![image-20230718193317156](/image-20230718193317156.png)

![image-20230718193713220](/image-20230718193713220.png)

![image-20230718193854975](/image-20230718193854975.png)

![image-20230718193906834](/image-20230718193906834.png)

![image-20230718193927201](/image-20230718193927201.png)

总结：

* 光有中序不行，不能确定根节点
* 中序搭配前后序都可以
* 缺了中序不行

技巧：

* 前序和中序组合中	
  * 找到根节点后
  * 子树的先序遍历部分第一个出现的一定是子根节点，剩余的按先左后右放置
  * 因为先序遍历中根节点出现在所有节点之前
* 后序和中序组合中
  * 找到根节点后
  * 子树的后序遍历部分最后一个出现的一定是根节点，剩余的按先左后右放置
  * 因为后序遍历中根节点出现在所有节点之后

#### 5.3.5 二叉树遍历的应用实例

![image-20230718195042652](/image-20230718195042652.png)

![image-20230718195148689](/image-20230718195148689.png)

![image-20230718195248985](/image-20230718195248985.png)

![image-20230718195343322](/image-20230718195343322.png)

* 后序遍历反而是在应用中最多的:thinking:

  不过其实所有遍历都可以改成应用

### 5.4 树和森林

![image-20230720102511458](/image-20230720102511458.png)

#### 5.4.1 森林与二叉树的转换（上）

![image-20230720102550042](/image-20230720102550042.png)

![image-20230720102615134](/image-20230720102615134.png)

![image-20230720102639184](/image-20230720102639184.png)

![image-20230720102702836](/image-20230720102702836.png)

![image-20230720102717758](/image-20230720102717758.png)

* 横向连接的转换为右子树
* 竖向连接的转换为左子树

![image-20230720102817301](/image-20230720102817301.png)

![image-20230720102840673](/image-20230720102840673.png)

![image-20230720102939488](/image-20230720102939488.png)

* 将森林看做多个普通树的组合，先将每棵树转化为二叉树，然后再将二叉树相互连接起来
* 树形成的二叉树的根节点没有右子树，根据这一性质，可以将下一棵树连接到前一棵二叉树的右子树位置上，以此类推可以将所有树都连接在一起形成一个二叉树

#### 5.4.2 森林和二叉树的转换（下）

![image-20230720103510001](/image-20230720103510001.png)

![image-20230720103647127](/image-20230720103647127.png)

* 只有在同一水平面有水平连线的节点之间才进行 对第一个节点的根节点进行连线。

![image-20230720103819385](/image-20230720103819385.png)

左子树形成孩子的关系，右子树会形成兄弟的关系

![image-20230720103959061](/image-20230720103959061.png)

![image-20230720104026090](/image-20230720104026090.png)

* 二叉树中的右子树共经过多少个节点就会形成多少个树的森林

#### 5.4.3 树和森林的存储表示

![image-20230720105628079](/image-20230720105628079.png)

![image-20230720105916453](/image-20230720105916453.png)

![image-20230720110020679](/image-20230720110020679.png)

* 此方法中的孩子兄嘚表示的是原来树中的孩子和兄弟，而在转化后的二叉树中右指针域代表的是右孩子。

![image-20230720110144001](/image-20230720110144001.png)

* 相较于孩子兄弟法多一个指向双亲节点的指针

![image-20230720110256434](/image-20230720110256434.png)

* 每个结点只会有一个双亲结点，使用层次遍历的方法按顺序排列并记录下标

![image-20230720110544247](/image-20230720110544247.png)

* 按照先序遍历进行编号排序，兄弟指针域存储原树的兄弟结点下标，孩子状态记录下一个下标对于的是否是其孩子结点

![image-20230720110600086](/image-20230720110600086.png)

#### 5.4.4 树和森林的遍历

![image-20230720111827943](/image-20230720111827943.png)

![image-20230720111944199](/image-20230720111944199.png)

![image-20230720112008311](/image-20230720112008311.png)

![image-20230720112108764](/image-20230720112108764.png)

![image-20230720112120992](/image-20230720112120992.png)

![image-20230720112153297](/image-20230720112153297.png)

![image-20230720112216750](/image-20230720112216750.png)

![image-20230720112310009](/image-20230720112310009.png)

![image-20230720112354122](/image-20230720112354122.png)

* 先序遍历、中序遍历、后序遍历森林和转换后的二叉树完全相同
* 先序和中序的遍历即是对森林中每一棵树的遍历的简单拼接
* 后序遍历有可能会将每棵树的遍历拆开，故不实用

### 5.5 堆和优先权队列

![image-20230720115459230](/image-20230720115459230.png)

#### 5.5.1 堆的概念级存储表示

![image-20230720115553586](/image-20230720115553586.png)

![image-20230720115623899](/image-20230720115623899.png)

![image-20230720115736647](/image-20230720115736647.png)

![image-20230720121634670](/image-20230720121634670.png)

![image-20230720122351998](/image-20230720122351998.png)

![image-20230720122424714](/image-20230720122424714.png)

![image-20230720122515350](/image-20230720122515350.png)

* 由于完全二叉树每层的节点数目是固定的，所以只需要有一个序列就可以还原出来堆

#### 5.5.2 建堆运算

![image-20230720132820294](/image-20230720132820294.png)

![image-20230720133000642](/image-20230720133000642.png)

![image-20230720133121373](/image-20230720133121373.png)

![image-20230720133229050](/image-20230720133229050.png)

![image-20230720133305459](/image-20230720133305459.png)

![image-20230720133347089](/image-20230720133347089.png)

![image-20230720133407859](/image-20230720133407859.png)

![image-20230720133452591](/image-20230720133452591.png)

![image-20230720133509485](/image-20230720133509485.png)

![image-20230720133524643](/image-20230720133524643.png)

![image-20230720133821269](/image-20230720133821269.png)

![image-20230720133900681](/image-20230720133900681.png)

* 结点进行一次向下调整后，需要对转换到的位置再进行一次检查，也就是对自身结点。

#### 5.5.3 优先权队列

![image-20230720143311143](/image-20230720143311143.png)

![image-20230720143421422](/image-20230720143421422.png)

![image-20230720143814824](/image-20230720143814824.png)

![image-20230720143928990](/image-20230720143928990.png)

![image-20230720143954916](/image-20230720143954916.png)

![image-20230720144053247](/image-20230720144053247.png)

![image-20230720144143500](/image-20230720144143500.png)

![image-20230720145726944](/image-20230720145726944.png)

![image-20230720145733396](/image-20230720145733396.png)

![image-20230720145901334](/image-20230720145901334.png)

#### 5.3.4 优先权队列（下）

![image-20230720150851171](/image-20230720150851171.png)

![image-20230720150925860](/image-20230720150925860.png)

![image-20230720151111641](/image-20230720151111641.png)

![image-20230720151300056](/image-20230720151300056.png)

* 取出元素的时候先将元素赋值，后用堆尾元素直接覆盖堆顶元素，然后对堆顶元素调用向下调整，使得堆顶元素是最小（最大）的元素，同时保证堆的结构合理。
* 在用堆尾元素覆盖堆顶元素时堆尾元素应该删除，这里使用的是直接将堆元素总数-1，即将下标前移，所以其实没有完全删除这个结点的值。

![image-20230720151659705](/image-20230720151659705.png)

![image-20230720151729891](/image-20230720151729891.png)

![image-20230720151859861](/image-20230720151859861.png)

### 5.6 哈夫曼树及哈夫曼编码

![image-20230720160101805](/image-20230720160101805.png)

#### 5.6.1 树的路径长度

![image-20230720160302911](/image-20230720160302911.png)

![image-20230720160320300](/image-20230720160320300.png)

![image-20230720160417280](/image-20230720160417280.png)

![image-20230720161615420](/image-20230720161615420.png)

![image-20230720161655567](/image-20230720161655567.png)

![image-20230720161842596](/image-20230720161842596.png)

![image-20230720161954173](/image-20230720161954173.png)

![image-20230720162044424](/image-20230720162044424.png)

![image-20230720162235992](/image-20230720162235992.png)

![image-20230720162327856](/image-20230720162327856.png)

#### 5.6.2 哈夫曼树和哈夫曼算法

![image-20230720164356668](/image-20230720164356668.png)

![image-20230720164920251](/image-20230720164920251.png)

![image-20230720165438177](/image-20230720165438177.png)

![image-20230720165458526](/image-20230720165458526.png)

![image-20230720165517043](/image-20230720165517043.png)

![image-20230720165546524](/image-20230720165546524.png)

![image-20230720193724147](/image-20230720193724147.png)

#### 5.6.3 哈弗曼编码

![image-20230720202314887](/image-20230720202314887.png)

![image-20230720202333144](/image-20230720202333144.png)

![image-20230720202452218](/image-20230720202452218.png)

![image-20230720202553171](/image-20230720202553171.png)

![image-20230720202706167](/image-20230720202706167.png)

## 第6章 集合和搜索

![image-20230721110126101](/image-20230721110126101.png)

### 6.1 集合的抽象数据类型

![image-20230721110142633](/image-20230721110142633.png)

![image-20230721110253057](/image-20230721110253057.png)

![image-20230721110411626](/image-20230721110411626.png)

![image-20230721110431837](/image-20230721110431837.png)

![image-20230721110451584](/image-20230721110451584.png)

![image-20230721111330541](/image-20230721111330541.png)

### 6.2 顺序搜索

![image-20230721111437695](/image-20230721111437695.png)

![image-20230721111525401](/image-20230721111525401.png)

![image-20230721111535015](/image-20230721111535015.png)

![image-20230721111641921](/image-20230721111641921.png)

![image-20230721111655944](/image-20230721111655944.png)

![image-20230721112525061](/image-20230721112525061.png)

![image-20230721112603041](/image-20230721112603041.png)

* 哨兵：有序表最后添加一个无穷大的数
* 用于停止for循环

### 6.3 二分搜索

![image-20230721190001596](/image-20230721190001596.png)

![image-20230721190155796](/image-20230721190155796.png)

![image-20230721190245627](/image-20230721190245627.png)

![image-20230721190255018](/image-20230721190255018.png)

![image-20230721190356412](/image-20230721190356412.png)

![image-20230721190408975](/image-20230721190408975.png)

![image-20230721190523533](/image-20230721190523533.png)

![image-20230721190657319](/image-20230721190657319.png)

* 感觉二分查找迭代法反而好理解一点
* 而且占用应该也会相较于递归的少很多

### 6.4 平均搜索长度分析

![image-20230721191709398](/image-20230721191709398.png)

![image-20230721191857910](/image-20230721191857910.png)

![image-20230721192003187](/image-20230721192003187.png)

![image-20230721192055837](/image-20230721192055837.png)

![image-20230721192133932](/image-20230721192133932.png)

![image-20230721192230807](/image-20230721192230807.png)

![image-20230721192517030](/image-20230721192517030.png)

![image-20230721192630811](/image-20230721192630811.png)

![image-20230721192719545](/image-20230721192719545.png)

![image-20230721192739806](/image-20230721192739806.png)

![image-20230721192755833](/image-20230721192755833.png)

* 搜索成功时落在内节点上，平均搜索长度为内路径长度/有序表长度
* 搜索失败时落在外结点上，平均搜索长度为外路径长度/有序表长度

**总结：**

**介绍了集合的顺序存储方式以及对应的顺序搜索方式和二分搜索方式，比较了时间复杂度**

## 第7章 搜索树

### 7.1 二叉搜索树

![image-20230727154428859](/image-20230727154428859.png)

#### 7.1.1 二叉搜索树的基本概念

![image-20230727154513331](/image-20230727154513331.png)

![image-20230727154626902](/image-20230727154626902.png)

![image-20230727154726481](/image-20230727154726481.png)

![image-20230727155032039](/image-20230727155032039.png)

![image-20230727155131685](/image-20230727155131685.png)

![image-20230727155249716](/image-20230727155249716.png)

![image-20230727155411507](/image-20230727155411507.png)

* 重点在于他的性质
* 左孩子的值＜结点值＜右孩子的值

#### 7.1.2 二叉搜索树的插入操作